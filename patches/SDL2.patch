diff -r 5ce21e1ca0c3 VisualC/SDL/SDL_VS2008.vcproj
--- a/VisualC/SDL/SDL_VS2008.vcproj	Mon Oct 14 09:15:41 2013 -0700
+++ b/VisualC/SDL/SDL_VS2008.vcproj	Sat Nov 16 12:08:10 2013 -0800
@@ -1,1338 +1,1340 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="SDL2"
-	ProjectGUID="{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}"
-	RootNamespace="SDL"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\Debug"
-			IntermediateDirectory=".\Debug"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName=".\Debug/SDL.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_DEBUG;_WINDOWS"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1033"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="winmm.lib imm32.lib version.lib"
-				IgnoreAllDefaultLibraries="true"
-				GenerateDebugInformation="true"
-				SubSystem="2"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName=".\Debug/SDL.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="_DEBUG;_WINDOWS"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="4"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1033"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="winmm.lib imm32.lib version.lib"
-				IgnoreAllDefaultLibraries="true"
-				GenerateDebugInformation="true"
-				SubSystem="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\Release"
-			IntermediateDirectory=".\Release"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName=".\Release/SDL.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				EnableIntrinsicFunctions="false"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="NDEBUG;_WINDOWS"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1033"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="winmm.lib imm32.lib version.lib"
-				IgnoreAllDefaultLibraries="true"
-				GenerateDebugInformation="true"
-				SubSystem="2"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName=".\Release/SDL.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				EnableIntrinsicFunctions="false"
-				AdditionalIncludeDirectories="..\..\include"
-				PreprocessorDefinitions="NDEBUG;_WINDOWS"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1033"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="winmm.lib imm32.lib version.lib"
-				IgnoreAllDefaultLibraries="true"
-				GenerateDebugInformation="true"
-				SubSystem="2"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="API Headers"
-			>
-			<File
-				RelativePath="..\..\include\SDL.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_assert.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_atomic.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_audio.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_bits.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_blendmode.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_clipboard.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_config.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_config_windows.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_copying.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_cpuinfo.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_endian.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_error.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_events.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_filesystem.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_gamecontroller.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_gesture.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_haptic.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_hints.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_joystick.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_keyboard.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_keycode.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_loadso.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_log.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_main.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_messagebox.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_mouse.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_mutex.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_name.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_opengl.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_opengles.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_pixels.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_platform.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_power.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_quit.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_rect.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_render.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_revision.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_rwops.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_scancode.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_shape.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_stdinc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_surface.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_system.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_syswm.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_thread.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_timer.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_touch.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_types.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_version.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\include\SDL_video.h"
-				>
-			</File>
-		</Filter>
-		<File
-			RelativePath="..\..\src\events\blank_cursor.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\default_cursor.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\directsound\directx.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\e_atan2.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\e_log.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\e_pow.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\e_rem_pio2.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\e_sqrt.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\k_cos.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\k_rem_pio2.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\k_sin.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\math.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\math_private.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\mmx.h"
-			>
-		</File>
-		<File
-			RelativePath=".\resource.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_atan.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_copysign.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_cos.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_fabs.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_floor.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_scalbn.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\libm\s_sin.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_assert.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\atomic\SDL_atomic.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audio.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audio_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audiocvt.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audiodev.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audiodev_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audiomem.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_audiotypecvt.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendfillrect.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendfillrect.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendline.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendline.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendpoint.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_blendpoint.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_0.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_1.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_A.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_auto.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_auto.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_copy.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_copy.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_N.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_slow.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_blit_slow.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_bmp.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_clipboard.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_clipboardevents.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_clipboardevents_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\cpuinfo\SDL_cpuinfo.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\directsound\SDL_directsound.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\directsound\SDL_directsound.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\disk\SDL_diskaudio.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\disk\SDL_diskaudio.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_draw.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_drawline.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_drawline.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_drawpoint.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_drawpoint.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_dropevents.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_dropevents_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\dummy\SDL_dummyaudio.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\dummy\SDL_dummyaudio.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\windows\SDL_dxjoystick.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_error.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_error_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_events.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_events_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_fillrect.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\SDL_gamecontroller.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_gesture.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_gesture_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_getenv.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_glesfuncs.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_glfuncs.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\haptic\SDL_haptic.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_hints.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_hints_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_iconv.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\SDL_joystick.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\SDL_joystick_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_keyboard.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_keyboard_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\SDL_log.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_malloc.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_mixer.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\windows\SDL_mmjoystick.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_mouse.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_mouse_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullevents.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullevents_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullframebuffer.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullframebuffer_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullvideo.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\dummy\SDL_nullvideo.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_pixels.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_pixels_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\power\SDL_power.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_qsort.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_quit.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_rect.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_rect_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\SDL_render.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\direct3d\SDL_render_d3d.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\opengl\SDL_render_gl.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_render_sw.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_render_sw_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_RLEaccel.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_RLEaccel_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_rotate.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\software\SDL_rotate.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\file\SDL_rwops.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\opengl\SDL_shaders_gl.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\opengl\SDL_shaders_gl.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_shape.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_shape_internals.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\atomic\SDL_spinlock.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_stdlib.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_stretch.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\stdlib\SDL_string.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_surface.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_sysaudio.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\generic\SDL_syscond.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_sysevents.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\filesystem\windows\SDL_sysfilesystem.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\haptic\windows\SDL_syshaptic.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\haptic\SDL_syshaptic.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\joystick\SDL_sysjoystick.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\loadso\windows\SDL_sysloadso.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\windows\SDL_sysmutex.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\power\windows\SDL_syspower.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\SDL_sysrender.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\windows\SDL_syssem.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\windows\SDL_systhread.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\windows\SDL_systls.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\SDL_systhread.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\windows\SDL_systhread_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\timer\windows\SDL_systimer.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\timer\SDL_systimer.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_sysvideo.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\SDL_thread.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\thread\SDL_thread_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\timer\SDL_timer.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\timer\SDL_timer_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_touch.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_touch_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\SDL_video.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_vkeys.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_wave.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\SDL_wave.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_windowevents.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\events\SDL_windowevents_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\core\windows\SDL_windows.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\core\windows\SDL_windows.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsclipboard.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsclipboard.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsevents.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsevents.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsframebuffer.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsframebuffer.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowskeyboard.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowskeyboard.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmessagebox.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmessagebox.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmodes.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmodes.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmouse.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsmouse.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsopengl.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsopengl.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsshape.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsshape.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsvideo.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowsvideo.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowswindow.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\SDL_windowswindow.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\winmm\SDL_winmm.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\winmm\SDL_winmm.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\audio\xaudio2\SDL_xaudio2.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\SDL_yuv_mmx.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\SDL_yuv_sw.c"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\render\SDL_yuv_sw_c.h"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\main\windows\version.rc"
-			>
-		</File>
-		<File
-			RelativePath="..\..\src\video\windows\wmmsg.h"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="SDL2"
+	ProjectGUID="{81CE8DAF-EBB2-4761-8E45-B71ABCCA8C68}"
+	RootNamespace="SDL"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/SDL.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_DEBUG;_WINDOWS"
+				ExceptionHandling="0"
+				RuntimeLibrary="3"
+				BufferSecurityCheck="false"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib imm32.lib version.lib"
+				IgnoreAllDefaultLibraries="true"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="mkdir $(SolutionDir)\..\lib&#x0D;&#x0A;mkdir $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2.dll $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2.lib $(SolutionDir)\..\lib\x86"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/SDL.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				EnableIntrinsicFunctions="false"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="NDEBUG;_WINDOWS"
+				StringPooling="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib imm32.lib version.lib"
+				IgnoreAllDefaultLibraries="true"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="mkdir $(SolutionDir)\..\lib&#x0D;&#x0A;mkdir $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2.dll $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2.lib $(SolutionDir)\..\lib\x86"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="3"
+				TypeLibraryName=".\Debug/SDL.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="_DEBUG;_WINDOWS"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib imm32.lib version.lib"
+				IgnoreAllDefaultLibraries="true"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="3"
+				TypeLibraryName=".\Release/SDL.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				EnableIntrinsicFunctions="false"
+				AdditionalIncludeDirectories="..\..\include"
+				PreprocessorDefinitions="NDEBUG;_WINDOWS"
+				StringPooling="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib imm32.lib version.lib"
+				IgnoreAllDefaultLibraries="true"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="API Headers"
+			>
+			<File
+				RelativePath="..\..\include\SDL.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_assert.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_atomic.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_audio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_bits.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_blendmode.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_clipboard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_config.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_config_windows.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_copying.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_cpuinfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_endian.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_error.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_events.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_filesystem.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_gamecontroller.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_gesture.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_haptic.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_hints.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_joystick.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_keyboard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_keycode.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_loadso.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_log.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_main.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_messagebox.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_mouse.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_mutex.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_name.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_opengl.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_opengles.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_pixels.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_platform.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_power.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_quit.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_rect.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_render.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_revision.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_rwops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_scancode.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_shape.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_stdinc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_surface.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_system.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_syswm.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_thread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_timer.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_touch.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_types.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_version.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\SDL_video.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="..\..\src\events\blank_cursor.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\default_cursor.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\directsound\directx.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\e_atan2.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\e_log.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\e_pow.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\e_rem_pio2.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\e_sqrt.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\k_cos.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\k_rem_pio2.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\k_sin.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\math.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\math_private.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\mmx.h"
+			>
+		</File>
+		<File
+			RelativePath=".\resource.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_atan.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_copysign.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_cos.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_fabs.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_floor.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_scalbn.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\libm\s_sin.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_assert.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\atomic\SDL_atomic.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audio.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audio_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audiocvt.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audiodev.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audiodev_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audiomem.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_audiotypecvt.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendfillrect.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendfillrect.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendline.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendline.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendpoint.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_blendpoint.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_0.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_1.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_A.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_auto.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_auto.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_copy.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_copy.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_N.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_slow.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_blit_slow.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_bmp.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_clipboard.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_clipboardevents.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_clipboardevents_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\cpuinfo\SDL_cpuinfo.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\directsound\SDL_directsound.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\directsound\SDL_directsound.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\disk\SDL_diskaudio.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\disk\SDL_diskaudio.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_draw.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_drawline.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_drawline.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_drawpoint.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_drawpoint.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_dropevents.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_dropevents_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\dummy\SDL_dummyaudio.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\dummy\SDL_dummyaudio.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\windows\SDL_dxjoystick.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_error.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_error_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_events.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_events_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_fillrect.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\SDL_gamecontroller.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_gesture.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_gesture_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_getenv.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_glesfuncs.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_glfuncs.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\haptic\SDL_haptic.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_hints.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_hints_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_iconv.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\SDL_joystick.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\SDL_joystick_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_keyboard.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_keyboard_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\SDL_log.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_malloc.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_mixer.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\windows\SDL_mmjoystick.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_mouse.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_mouse_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullevents.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullevents_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullframebuffer.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullframebuffer_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullvideo.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\dummy\SDL_nullvideo.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_pixels.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_pixels_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\power\SDL_power.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_qsort.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_quit.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_rect.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_rect_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\SDL_render.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\direct3d\SDL_render_d3d.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\opengl\SDL_render_gl.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_render_sw.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_render_sw_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_RLEaccel.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_RLEaccel_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_rotate.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\software\SDL_rotate.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\file\SDL_rwops.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\opengl\SDL_shaders_gl.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\opengl\SDL_shaders_gl.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_shape.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_shape_internals.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\atomic\SDL_spinlock.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_stdlib.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_stretch.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\stdlib\SDL_string.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_surface.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_sysaudio.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\generic\SDL_syscond.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_sysevents.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\filesystem\windows\SDL_sysfilesystem.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\haptic\windows\SDL_syshaptic.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\haptic\SDL_syshaptic.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\joystick\SDL_sysjoystick.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\loadso\windows\SDL_sysloadso.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\windows\SDL_sysmutex.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\power\windows\SDL_syspower.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\SDL_sysrender.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\windows\SDL_syssem.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\windows\SDL_systhread.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\SDL_systhread.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\windows\SDL_systhread_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\timer\windows\SDL_systimer.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\timer\SDL_systimer.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\windows\SDL_systls.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_sysvideo.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\SDL_thread.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\thread\SDL_thread_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\timer\SDL_timer.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\timer\SDL_timer_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_touch.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_touch_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\SDL_video.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_vkeys.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_wave.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\SDL_wave.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_windowevents.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\events\SDL_windowevents_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\core\windows\SDL_windows.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\core\windows\SDL_windows.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsclipboard.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsclipboard.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsevents.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsevents.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsframebuffer.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsframebuffer.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowskeyboard.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowskeyboard.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmessagebox.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmessagebox.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmodes.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmodes.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmouse.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsmouse.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsopengl.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsopengl.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsshape.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsshape.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsvideo.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowsvideo.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowswindow.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\SDL_windowswindow.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\winmm\SDL_winmm.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\winmm\SDL_winmm.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\audio\xaudio2\SDL_xaudio2.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\SDL_yuv_mmx.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\SDL_yuv_sw.c"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\render\SDL_yuv_sw_c.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\main\windows\version.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\video\windows\wmmsg.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 5ce21e1ca0c3 VisualC/SDLmain/SDLmain_VS2008.vcproj
--- a/VisualC/SDLmain/SDLmain_VS2008.vcproj	Mon Oct 14 09:15:41 2013 -0700
+++ b/VisualC/SDLmain/SDLmain_VS2008.vcproj	Sat Nov 16 12:08:10 2013 -0800
@@ -1,424 +1,427 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="SDL2main"
-	ProjectGUID="{DA956FD3-E142-46F2-9DD5-C78BEBB56B7A}"
-	RootNamespace="SDLmain"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\Release"
-			IntermediateDirectory=".\Release"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
-				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
-				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release_NoSTDIO|Win32"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				ExceptionHandling="0"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release_NoSTDIO|x64"
-			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
-				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS,NO_STDIO_REDIRECT"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				OutputFile="$(IntDir)\SDLmain.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\Debug"
-			IntermediateDirectory=".\Debug"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				CommandLine=""
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
-				PreprocessorDefinitions="WIN32,_DEBUG,_WINDOWS"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
-				PreprocessorDefinitions="WIN32,_DEBUG,_WINDOWS"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<File
-			RelativePath="..\..\src\main\windows\SDL_windows_main.c"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="SDL2main"
+	ProjectGUID="{DA956FD3-E142-46F2-9DD5-C78BEBB56B7A}"
+	RootNamespace="SDLmain"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
+				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS"
+				StringPooling="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="1"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="mkdir $(SolutionDir)\..\lib&#x0D;&#x0A;mkdir $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2main.lib $(SolutionDir)\..\lib\x86&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release_NoSTDIO|Win32"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				ExceptionHandling="0"
+				DebugInformationFormat="1"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="mkdir $(SolutionDir)\..\lib&#x0D;&#x0A;mkdir $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2main.lib $(SolutionDir)\..\lib\x86&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine=""
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
+				PreprocessorDefinitions="WIN32,_DEBUG,_WINDOWS"
+				ExceptionHandling="0"
+				RuntimeLibrary="3"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="1"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="mkdir $(SolutionDir)\..\lib&#x0D;&#x0A;mkdir $(SolutionDir)\..\lib\x86&#x0D;&#x0A;copy $(TargetDir)\SDL2main.lib $(SolutionDir)\..\lib\x86&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
+				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS"
+				StringPooling="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="1"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release_NoSTDIO|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
+				PreprocessorDefinitions="WIN32,NDEBUG,_WINDOWS,NO_STDIO_REDIRECT"
+				StringPooling="true"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="1"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="$(IntDir)\SDLmain.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC70.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\include,..\..\include\SDL"
+				PreprocessorDefinitions="WIN32,_DEBUG,_WINDOWS"
+				ExceptionHandling="0"
+				RuntimeLibrary="2"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="1"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\src\main\windows\SDL_windows_main.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 5ce21e1ca0c3 android-project/src/org/libsdl/app/SDLActivity.java
--- a/android-project/src/org/libsdl/app/SDLActivity.java	Mon Oct 14 09:15:41 2013 -0700
+++ b/android-project/src/org/libsdl/app/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -16,6 +16,10 @@
 import android.media.*;
 import android.hardware.*;
 
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
 
 /**
     SDL Activity
@@ -34,6 +38,9 @@
 
     // This is what SDL runs in. It invokes SDL_main(), eventually
     protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
 
     // Audio
     protected static Thread mAudioThread;
@@ -236,6 +243,10 @@
     public static native void nativePause();
     public static native void nativeResume();
     public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
     public static native void onNativeKeyDown(int keycode);
     public static native void onNativeKeyUp(int keycode);
     public static native void onNativeKeyboardFocusLost();
@@ -255,6 +266,62 @@
         // Called from SDLMain() thread and can't directly affect the view
         return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
     }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
 
     public static boolean sendMessage(int command, int param) {
         return mSingleton.sendCommand(command, Integer.valueOf(param));
@@ -449,6 +516,10 @@
         setOnTouchListener(this);   
 
         mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
 
         // Some arbitrary defaults to avoid a potential division by zero
         mWidth = 1.0f;
@@ -555,16 +626,26 @@
     // Key events
     @Override
     public boolean onKey(View  v, int keyCode, KeyEvent event) {
-        
-        if (event.getAction() == KeyEvent.ACTION_DOWN) {
-            //Log.v("SDL", "key down: " + keyCode);
-            SDLActivity.onNativeKeyDown(keyCode);
-            return true;
-        }
-        else if (event.getAction() == KeyEvent.ACTION_UP) {
-            //Log.v("SDL", "key up: " + keyCode);
-            SDLActivity.onNativeKeyUp(keyCode);
-            return true;
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
         }
         
         return false;
@@ -627,6 +708,31 @@
         }
     }
     
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
 }
 
 /* This is a fake invisible editor view that receives the input and defines the
diff -r 5ce21e1ca0c3 android/drummix/.classpath
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/.classpath	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -r 5ce21e1ca0c3 android/drummix/.project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/.project	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Drum Mix</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -r 5ce21e1ca0c3 android/drummix/.settings/org.eclipse.ltk.core.refactoring.prefs
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/.settings/org.eclipse.ltk.core.refactoring.prefs	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.ltk.core.refactoring.enable.project.refactoring.history=false
diff -r 5ce21e1ca0c3 android/drummix/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/AndroidManifest.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Replace org.libsdl.app with the identifier of your game below, e.g.
+     com.gamemaker.game
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libsdl.drummix"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <!-- Create a Java class extending SDLActivity and place it in a
+         directory under src matching the package, e.g.
+         	src/com/gamemaker/game/MyGame.java
+
+         then replace "SDLActivity" with the name of your class (e.g. "MyGame")
+         in the XML below.
+
+         An example Java class can be found in README-android.txt
+    -->
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/ic_launcher"
+                 android:allowBackup="true"
+                 android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="SDLActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+            
+    </application>
+
+    <!-- Android 2.3.3 -->
+    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="16" />
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 
diff -r 5ce21e1ca0c3 android/drummix/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/ant.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/drummix/build.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/build.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/drummix/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/build.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="Drum Mix" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 5ce21e1ca0c3 android/drummix/clean.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/clean.sh	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,5 @@
+rm -rf bin
+rm -rf gen
+rm -rf obj
+rm -rf libs
+rm -f assets/*.wav
diff -r 5ce21e1ca0c3 android/drummix/default.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/default.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-7
diff -r 5ce21e1ca0c3 android/drummix/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/jni/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,1 @@
+include $(call all-subdir-makefiles)
diff -r 5ce21e1ca0c3 android/drummix/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/jni/Application.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,6 @@
+APP_ABI := armeabi
+APP_PLATFORM := android-9
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
diff -r 5ce21e1ca0c3 android/drummix/jni/SDL/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/jni/SDL/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,50 @@
+LOCAL_PATH := $(SDL2_HOME)
+
+###########################
+#
+# SDL shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := SDL2
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	$(subst $(LOCAL_PATH)/,, \
+	$(wildcard $(LOCAL_PATH)/src/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/dummy/*.c) \
+	$(LOCAL_PATH)/src/atomic/SDL_atomic.c \
+	$(LOCAL_PATH)/src/atomic/SDL_spinlock.c.arm \
+	$(wildcard $(LOCAL_PATH)/src/core/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/cpuinfo/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/events/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/file/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/dummy/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/loadso/dlopen/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/stdlib/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/pthread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c))
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DSDL_PREFIX=org_libsdl_drummix
+LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/drummix/jni/src/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/jni/src/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,41 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+ifdef "$(SDL2_HOME)"
+  SDL2_PATH := $(SDL2_HOME)
+else
+  SDL2_PATH := ../../../..
+endif
+
+LOCAL_C_INCLUDES := $(SDL2_PATH)/include
+
+.PHONY: all clean
+
+all : post-build
+
+# Copy assets
+ASSETS_PATH = assets
+ASSETS_SRC = $(SDL2_HOME)/Xcode-iOS/Demos/data/drums
+
+post-build:
+	@echo Copy assets
+	cp $(ASSETS_SRC)/ds_brush_snare.wav $(ASSETS_PATH)
+	cp $(ASSETS_SRC)/ds_china.wav $(ASSETS_PATH)
+	cp $(ASSETS_SRC)/ds_kick_big_amb.wav $(ASSETS_PATH)
+	cp $(ASSETS_SRC)/ds_loose_skin_mute.wav $(ASSETS_PATH)
+
+# Add your application source files here...
+LOCAL_SRC_FILES := $(SDL2_PATH)/src/main/android/SDL_android_main.c \
+	$(SDL2_PATH)/Xcode-iOS/Demos/src/common.c \
+	$(SDL2_PATH)/Xcode-iOS/Demos/src/mixer.c
+
+LOCAL_CFLAGS += -DSDL_PREFIX=org_libsdl_drummix
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/drummix/lint.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/lint.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff -r 5ce21e1ca0c3 android/drummix/proguard-project.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/proguard-project.txt	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -r 5ce21e1ca0c3 android/drummix/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/project.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
diff -r 5ce21e1ca0c3 android/drummix/res/drawable-hdpi/ic_launcher.png
Binary file android/drummix/res/drawable-hdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/drummix/res/drawable-mdpi/ic_launcher.png
Binary file android/drummix/res/drawable-mdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/drummix/res/drawable-xhdpi/ic_launcher.png
Binary file android/drummix/res/drawable-xhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/drummix/res/drawable-xxhdpi/ic_launcher.png
Binary file android/drummix/res/drawable-xxhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/drummix/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/res/layout/main.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+
diff -r 5ce21e1ca0c3 android/drummix/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/res/values/strings.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Drum Mix</string>
+</resources>
diff -r 5ce21e1ca0c3 android/drummix/src/org/libsdl/drummix/SDLActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/drummix/src/org/libsdl/drummix/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,856 @@
+package org.libsdl.drummix;
+
+import java.util.Arrays;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused = false, mIsSurfaceReady = false, mHasFocus = true;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
+
+    // Audio
+    protected static Thread mAudioThread;
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        //System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        //Log.v("SDL", "onCreate()");
+        super.onCreate(savedInstanceState);
+        
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (mSDLThread != null) {
+            try {
+                mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
+        }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+             final int touchDevId = event.getDeviceId();
+             final int pointerCount = event.getPointerCount();
+             // touchId, pointerId, action, x, y, pressure
+             int actionPointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT; /* API 8: event.getActionIndex(); */
+             int pointerFingerId = event.getPointerId(actionPointerIndex);
+             int action = (event.getAction() & MotionEvent.ACTION_MASK); /* API 8: event.getActionMasked(); */
+
+             float x = event.getX(actionPointerIndex) / mWidth;
+             float y = event.getY(actionPointerIndex) / mHeight;
+             float p = event.getPressure(actionPointerIndex);
+
+             if (action == MotionEvent.ACTION_MOVE && pointerCount > 1) {
+                // TODO send motion to every pointer if its position has
+                // changed since prev event.
+                for (int i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+             } else {
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+             }
+      return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            SDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,
+                                      event.values[1] / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH);
+        }
+    }
+    
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+}
+
diff -r 5ce21e1ca0c3 android/fireworks/.classpath
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/.classpath	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -r 5ce21e1ca0c3 android/fireworks/.project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/.project	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>fireworks</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -r 5ce21e1ca0c3 android/fireworks/.settings/org.eclipse.ltk.core.refactoring.prefs
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/.settings/org.eclipse.ltk.core.refactoring.prefs	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.ltk.core.refactoring.enable.project.refactoring.history=false
diff -r 5ce21e1ca0c3 android/fireworks/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/AndroidManifest.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Replace org.libsdl.app with the identifier of your game below, e.g.
+     com.gamemaker.game
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libsdl.fireworks"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <!-- Create a Java class extending SDLActivity and place it in a
+         directory under src matching the package, e.g.
+         	src/com/gamemaker/game/MyGame.java
+
+         then replace "SDLActivity" with the name of your class (e.g. "MyGame")
+         in the XML below.
+
+         An example Java class can be found in README-android.txt
+    -->
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/ic_launcher"
+                 android:allowBackup="true"
+                 android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="SDLActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+            
+    </application>
+
+    <!-- Android 2.3.3 -->
+    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="16" />
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 
diff -r 5ce21e1ca0c3 android/fireworks/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/ant.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/fireworks/build.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/build.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/fireworks/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/build.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="Fireworks" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 5ce21e1ca0c3 android/fireworks/clean.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/clean.sh	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,5 @@
+rm -rf bin
+rm -rf gen
+rm -rf obj
+rm -rf libs
+rm -f assets/*.bmp
diff -r 5ce21e1ca0c3 android/fireworks/default.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/default.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-7
diff -r 5ce21e1ca0c3 android/fireworks/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/jni/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,1 @@
+include $(call all-subdir-makefiles)
diff -r 5ce21e1ca0c3 android/fireworks/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/jni/Application.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,6 @@
+APP_ABI := armeabi
+APP_PLATFORM := android-9
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
diff -r 5ce21e1ca0c3 android/fireworks/jni/SDL/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/jni/SDL/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,50 @@
+LOCAL_PATH := $(SDL2_HOME)
+
+###########################
+#
+# SDL shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := SDL2
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	$(subst $(LOCAL_PATH)/,, \
+	$(wildcard $(LOCAL_PATH)/src/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/dummy/*.c) \
+	$(LOCAL_PATH)/src/atomic/SDL_atomic.c \
+	$(LOCAL_PATH)/src/atomic/SDL_spinlock.c.arm \
+	$(wildcard $(LOCAL_PATH)/src/core/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/cpuinfo/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/events/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/file/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/dummy/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/loadso/dlopen/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/stdlib/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/pthread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c))
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DSDL_PREFIX=org_libsdl_fireworks
+LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/fireworks/jni/src/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/jni/src/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,38 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+ifdef "$(SDL2_HOME)"
+  SDL2_PATH := $(SDL2_HOME)
+else
+  SDL2_PATH := ../../../..
+endif
+
+LOCAL_C_INCLUDES := $(SDL_PATH)/include
+
+.PHONY: all clean
+
+all : post-build
+
+# Copy assets
+ASSETS_PATH = assets
+ASSETS_SRC = ../../Xcode-iOS/Demos/data
+
+post-build:
+	@echo Copy assets
+	cp $(ASSETS_SRC)/stroke.bmp $(ASSETS_PATH)
+
+# Add your application source files here...
+LOCAL_SRC_FILES := $(SDL2_PATH)/src/main/android/SDL_android_main.c \
+	$(SDL2_PATH)/Xcode-iOS/Demos/src/fireworks.c \
+	$(SDL2_PATH)/Xcode-iOS/Demos/src/common.c
+
+LOCAL_CFLAGS += -DSDL_PREFIX=org_libsdl_fireworks
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/fireworks/lint.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/lint.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff -r 5ce21e1ca0c3 android/fireworks/proguard-project.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/proguard-project.txt	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -r 5ce21e1ca0c3 android/fireworks/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/project.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
diff -r 5ce21e1ca0c3 android/fireworks/res/drawable-hdpi/ic_launcher.png
Binary file android/fireworks/res/drawable-hdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/fireworks/res/drawable-mdpi/ic_launcher.png
Binary file android/fireworks/res/drawable-mdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/fireworks/res/drawable-xhdpi/ic_launcher.png
Binary file android/fireworks/res/drawable-xhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/fireworks/res/drawable-xxhdpi/ic_launcher.png
Binary file android/fireworks/res/drawable-xxhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/fireworks/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/res/layout/main.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+
diff -r 5ce21e1ca0c3 android/fireworks/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/res/values/strings.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Fireworks</string>
+</resources>
diff -r 5ce21e1ca0c3 android/fireworks/src/org/libsdl/fireworks/SDLActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/fireworks/src/org/libsdl/fireworks/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,856 @@
+package org.libsdl.fireworks;
+
+import java.util.Arrays;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused = false, mIsSurfaceReady = false, mHasFocus = true;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
+
+    // Audio
+    protected static Thread mAudioThread;
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        //System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        //Log.v("SDL", "onCreate()");
+        super.onCreate(savedInstanceState);
+        
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (mSDLThread != null) {
+            try {
+                mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
+        }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+             final int touchDevId = event.getDeviceId();
+             final int pointerCount = event.getPointerCount();
+             // touchId, pointerId, action, x, y, pressure
+             int actionPointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT; /* API 8: event.getActionIndex(); */
+             int pointerFingerId = event.getPointerId(actionPointerIndex);
+             int action = (event.getAction() & MotionEvent.ACTION_MASK); /* API 8: event.getActionMasked(); */
+
+             float x = event.getX(actionPointerIndex) / mWidth;
+             float y = event.getY(actionPointerIndex) / mHeight;
+             float p = event.getPressure(actionPointerIndex);
+
+             if (action == MotionEvent.ACTION_MOVE && pointerCount > 1) {
+                // TODO send motion to every pointer if its position has
+                // changed since prev event.
+                for (int i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+             } else {
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+             }
+      return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            SDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,
+                                      event.values[1] / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH);
+        }
+    }
+    
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+}
+
diff -r 5ce21e1ca0c3 android/spritetest2/.classpath
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/.classpath	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -r 5ce21e1ca0c3 android/spritetest2/.project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/.project	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Sprite Test 2</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -r 5ce21e1ca0c3 android/spritetest2/.settings/org.eclipse.ltk.core.refactoring.prefs
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/.settings/org.eclipse.ltk.core.refactoring.prefs	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.ltk.core.refactoring.enable.project.refactoring.history=false
diff -r 5ce21e1ca0c3 android/spritetest2/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/AndroidManifest.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Replace org.libsdl.app with the identifier of your game below, e.g.
+     com.gamemaker.game
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libsdl.spritetest2"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <!-- Create a Java class extending SDLActivity and place it in a
+         directory under src matching the package, e.g.
+         	src/com/gamemaker/game/MyGame.java
+
+         then replace "SDLActivity" with the name of your class (e.g. "MyGame")
+         in the XML below.
+
+         An example Java class can be found in README-android.txt
+    -->
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/ic_launcher"
+                 android:allowBackup="true"
+                 android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="SDLActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="tv.ouya.intent.category.APP"/>
+                </intent-filter>
+        </activity>
+            
+    </application>
+
+    <!-- Android 2.3.3 -->
+    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="10" />
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 
diff -r 5ce21e1ca0c3 android/spritetest2/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/ant.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/spritetest2/build.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/build.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/spritetest2/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/build.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="Sprite Test 2" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 5ce21e1ca0c3 android/spritetest2/clean.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/clean.sh	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,5 @@
+rm -rf bin
+rm -rf gen
+rm -rf obj
+rm -rf libs
+rm -f assets/*.bmp
diff -r 5ce21e1ca0c3 android/spritetest2/default.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/default.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-7
diff -r 5ce21e1ca0c3 android/spritetest2/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/jni/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,1 @@
+include $(call all-subdir-makefiles)
diff -r 5ce21e1ca0c3 android/spritetest2/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/jni/Application.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,6 @@
+APP_ABI := armeabi
+APP_PLATFORM := android-9
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
diff -r 5ce21e1ca0c3 android/spritetest2/jni/SDL/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/jni/SDL/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,50 @@
+LOCAL_PATH := $(SDL2_HOME)
+
+###########################
+#
+# SDL shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := SDL2
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	$(subst $(LOCAL_PATH)/,, \
+	$(wildcard $(LOCAL_PATH)/src/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/dummy/*.c) \
+	$(LOCAL_PATH)/src/atomic/SDL_atomic.c \
+	$(LOCAL_PATH)/src/atomic/SDL_spinlock.c.arm \
+	$(wildcard $(LOCAL_PATH)/src/core/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/cpuinfo/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/events/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/file/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/dummy/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/loadso/dlopen/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/stdlib/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/pthread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c))
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DSDL_PREFIX=org_libsdl_spritetest2
+LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/spritetest2/jni/src/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/jni/src/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,40 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+ifdef "$(SDL2_HOME)"
+  SDL2_PATH := $(SDL2_HOME)
+else
+  SDL2_PATH := ../../../..
+endif
+
+LOCAL_C_INCLUDES := $(SDL_PATH)/include
+
+.PHONY: all clean
+
+all : post-build
+
+# Copy assets
+ASSETS_PATH = assets
+ASSETS_SRC = $(SDL2_HOME)/Xcode-iOS/Demos/data
+
+post-build:
+	@echo Copy assets
+	cp $(ASSETS_SRC)/icon.bmp $(ASSETS_PATH)
+
+# Add your application source files here...
+LOCAL_SRC_FILES := $(SDL2_PATH)/src/main/android/SDL_android_main.c \
+	$(SDL2_PATH)/test/testsprite2.c \
+	$(SDL2_PATH)/src/test/SDL_test_common.c \
+	$(SDL2_PATH)/src/test/SDL_test_fuzzer.c \
+	$(SDL2_PATH)/src/test/SDL_test_random.c
+
+LOCAL_CFLAGS += -DSDL_PREFIX=org_libsdl_spritetest2
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/spritetest2/lint.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/lint.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff -r 5ce21e1ca0c3 android/spritetest2/proguard-project.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/proguard-project.txt	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -r 5ce21e1ca0c3 android/spritetest2/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/project.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
diff -r 5ce21e1ca0c3 android/spritetest2/res/drawable-hdpi/ic_launcher.png
Binary file android/spritetest2/res/drawable-hdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/spritetest2/res/drawable-mdpi/ic_launcher.png
Binary file android/spritetest2/res/drawable-mdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/spritetest2/res/drawable-xhdpi/ic_launcher.png
Binary file android/spritetest2/res/drawable-xhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/spritetest2/res/drawable-xxhdpi/ic_launcher.png
Binary file android/spritetest2/res/drawable-xxhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/spritetest2/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/res/layout/main.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+
diff -r 5ce21e1ca0c3 android/spritetest2/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/res/values/strings.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Sprite Test2</string>
+</resources>
diff -r 5ce21e1ca0c3 android/spritetest2/src/org/libsdl/spritetest2/SDLActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/spritetest2/src/org/libsdl/spritetest2/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,856 @@
+package org.libsdl.spritetest2;
+
+import java.util.Arrays;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused = false, mIsSurfaceReady = false, mHasFocus = true;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
+
+    // Audio
+    protected static Thread mAudioThread;
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        //System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        //Log.v("SDL", "onCreate()");
+        super.onCreate(savedInstanceState);
+        
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (mSDLThread != null) {
+            try {
+                mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
+        }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+             final int touchDevId = event.getDeviceId();
+             final int pointerCount = event.getPointerCount();
+             // touchId, pointerId, action, x, y, pressure
+             int actionPointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT; /* API 8: event.getActionIndex(); */
+             int pointerFingerId = event.getPointerId(actionPointerIndex);
+             int action = (event.getAction() & MotionEvent.ACTION_MASK); /* API 8: event.getActionMasked(); */
+
+             float x = event.getX(actionPointerIndex) / mWidth;
+             float y = event.getY(actionPointerIndex) / mHeight;
+             float p = event.getPressure(actionPointerIndex);
+
+             if (action == MotionEvent.ACTION_MOVE && pointerCount > 1) {
+                // TODO send motion to every pointer if its position has
+                // changed since prev event.
+                for (int i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+             } else {
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+             }
+      return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            SDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,
+                                      event.values[1] / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH);
+        }
+    }
+    
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+}
+
diff -r 5ce21e1ca0c3 android/testgles/.classpath
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/.classpath	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -r 5ce21e1ca0c3 android/testgles/.project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/.project	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test GLES</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -r 5ce21e1ca0c3 android/testgles/.settings/org.eclipse.ltk.core.refactoring.prefs
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/.settings/org.eclipse.ltk.core.refactoring.prefs	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.ltk.core.refactoring.enable.project.refactoring.history=false
diff -r 5ce21e1ca0c3 android/testgles/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/AndroidManifest.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Replace org.libsdl.app with the identifier of your game below, e.g.
+     com.gamemaker.game
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libsdl.testgles"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <!-- Create a Java class extending SDLActivity and place it in a
+         directory under src matching the package, e.g.
+         	src/com/gamemaker/game/MyGame.java
+
+         then replace "SDLActivity" with the name of your class (e.g. "MyGame")
+         in the XML below.
+
+         An example Java class can be found in README-android.txt
+    -->
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/ic_launcher"
+                 android:allowBackup="true"
+                 android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="SDLActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+            
+    </application>
+
+    <!-- Android 2.3.3 -->
+    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="16" />
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 
diff -r 5ce21e1ca0c3 android/testgles/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/ant.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/testgles/build.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/build.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/testgles/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/build.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="Test GLES" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 5ce21e1ca0c3 android/testgles/clean.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/clean.sh	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+rm -rf bin
+rm -rf gen
+rm -rf obj
+rm -rf libs
diff -r 5ce21e1ca0c3 android/testgles/default.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/default.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-7
diff -r 5ce21e1ca0c3 android/testgles/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/jni/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,1 @@
+include $(call all-subdir-makefiles)
diff -r 5ce21e1ca0c3 android/testgles/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/jni/Application.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,6 @@
+APP_ABI := armeabi
+APP_PLATFORM := android-9
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
diff -r 5ce21e1ca0c3 android/testgles/jni/SDL/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/jni/SDL/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,50 @@
+LOCAL_PATH := $(SDL2_HOME)
+
+###########################
+#
+# SDL shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := SDL2
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	$(subst $(LOCAL_PATH)/,, \
+	$(wildcard $(LOCAL_PATH)/src/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/dummy/*.c) \
+	$(LOCAL_PATH)/src/atomic/SDL_atomic.c \
+	$(LOCAL_PATH)/src/atomic/SDL_spinlock.c.arm \
+	$(wildcard $(LOCAL_PATH)/src/core/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/cpuinfo/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/events/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/file/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/dummy/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/loadso/dlopen/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/stdlib/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/pthread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c))
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DSDL_PREFIX=org_libsdl_testgles
+LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/testgles/jni/src/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/jni/src/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,22 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+SDL_PATH := ../../../..
+
+LOCAL_C_INCLUDES := $(SDL_PATH)/include
+
+# Add your application source files here...
+LOCAL_SRC_FILES := $(SDL_PATH)/src/main/android/SDL_android_main.c \
+	$(SDL_PATH)/test/testgles.c \
+	$(SDL_PATH)/src/test/SDL_test_common.c
+
+LOCAL_CFLAGS += -DSDL_PREFIX=org_libsdl_testgles
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/testgles/lint.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/lint.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff -r 5ce21e1ca0c3 android/testgles/proguard-project.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/proguard-project.txt	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -r 5ce21e1ca0c3 android/testgles/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/project.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
diff -r 5ce21e1ca0c3 android/testgles/res/drawable-hdpi/ic_launcher.png
Binary file android/testgles/res/drawable-hdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testgles/res/drawable-mdpi/ic_launcher.png
Binary file android/testgles/res/drawable-mdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testgles/res/drawable-xhdpi/ic_launcher.png
Binary file android/testgles/res/drawable-xhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testgles/res/drawable-xxhdpi/ic_launcher.png
Binary file android/testgles/res/drawable-xxhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testgles/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/res/layout/main.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+
diff -r 5ce21e1ca0c3 android/testgles/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/res/values/strings.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Test GLES</string>
+</resources>
diff -r 5ce21e1ca0c3 android/testgles/src/org/libsdl/testgles/SDLActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testgles/src/org/libsdl/testgles/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,856 @@
+package org.libsdl.testgles;
+
+import java.util.Arrays;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused = false, mIsSurfaceReady = false, mHasFocus = true;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
+
+    // Audio
+    protected static Thread mAudioThread;
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        //System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        //Log.v("SDL", "onCreate()");
+        super.onCreate(savedInstanceState);
+        
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (mSDLThread != null) {
+            try {
+                mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
+        }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+             final int touchDevId = event.getDeviceId();
+             final int pointerCount = event.getPointerCount();
+             // touchId, pointerId, action, x, y, pressure
+             int actionPointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT; /* API 8: event.getActionIndex(); */
+             int pointerFingerId = event.getPointerId(actionPointerIndex);
+             int action = (event.getAction() & MotionEvent.ACTION_MASK); /* API 8: event.getActionMasked(); */
+
+             float x = event.getX(actionPointerIndex) / mWidth;
+             float y = event.getY(actionPointerIndex) / mHeight;
+             float p = event.getPressure(actionPointerIndex);
+
+             if (action == MotionEvent.ACTION_MOVE && pointerCount > 1) {
+                // TODO send motion to every pointer if its position has
+                // changed since prev event.
+                for (int i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+             } else {
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+             }
+      return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            SDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,
+                                      event.values[1] / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH);
+        }
+    }
+    
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+}
+
diff -r 5ce21e1ca0c3 android/testjoystick/.classpath
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/.classpath	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -r 5ce21e1ca0c3 android/testjoystick/.project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/.project	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test Joystick</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -r 5ce21e1ca0c3 android/testjoystick/.settings/org.eclipse.ltk.core.refactoring.prefs
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/.settings/org.eclipse.ltk.core.refactoring.prefs	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+org.eclipse.ltk.core.refactoring.enable.project.refactoring.history=false
diff -r 5ce21e1ca0c3 android/testjoystick/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/AndroidManifest.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Replace org.libsdl.app with the identifier of your game below, e.g.
+     com.gamemaker.game
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libsdl.testjoystick"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <!-- Create a Java class extending SDLActivity and place it in a
+         directory under src matching the package, e.g.
+         	src/com/gamemaker/game/MyGame.java
+
+         then replace "SDLActivity" with the name of your class (e.g. "MyGame")
+         in the XML below.
+
+         An example Java class can be found in README-android.txt
+    -->
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/ic_launcher"
+                 android:allowBackup="true"
+                 android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="SDLActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+            
+    </application>
+
+    <!-- Android 2.3.3 -->
+    <uses-sdk android:minSdkVersion="12" android:targetSdkVersion="16" />
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 
diff -r 5ce21e1ca0c3 android/testjoystick/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/ant.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/testjoystick/build.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/build.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 5ce21e1ca0c3 android/testjoystick/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/build.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="Joy Test" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 5ce21e1ca0c3 android/testjoystick/clean.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/clean.sh	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+rm -rf bin
+rm -rf gen
+rm -rf obj
+rm -rf libs
diff -r 5ce21e1ca0c3 android/testjoystick/default.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/default.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-7
diff -r 5ce21e1ca0c3 android/testjoystick/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/jni/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,1 @@
+include $(call all-subdir-makefiles)
diff -r 5ce21e1ca0c3 android/testjoystick/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/jni/Application.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,6 @@
+APP_ABI := armeabi
+APP_PLATFORM := android-9
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
diff -r 5ce21e1ca0c3 android/testjoystick/jni/SDL/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/jni/SDL/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,50 @@
+LOCAL_PATH := $(SDL2_HOME)
+
+###########################
+#
+# SDL shared library
+#
+###########################
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := SDL2
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	$(subst $(LOCAL_PATH)/,, \
+	$(wildcard $(LOCAL_PATH)/src/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/audio/dummy/*.c) \
+	$(LOCAL_PATH)/src/atomic/SDL_atomic.c \
+	$(LOCAL_PATH)/src/atomic/SDL_spinlock.c.arm \
+	$(wildcard $(LOCAL_PATH)/src/core/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/cpuinfo/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/events/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/file/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/haptic/dummy/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/joystick/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/loadso/dlopen/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/power/android/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/render/*/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/stdlib/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/thread/pthread/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c))
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DSDL_PREFIX=org_libsdl_testjoystick
+LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/testjoystick/jni/src/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/jni/src/Android.mk	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,21 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+SDL2_PATH := ../../../..
+
+LOCAL_C_INCLUDES := $(SDL2_PATH)/include
+
+# Add your application source files here...
+LOCAL_SRC_FILES := $(SDL2_PATH)/src/main/android/SDL_android_main.c \
+	$(SDL2_PATH)/test/testjoystick.c
+
+LOCAL_CFLAGS += -DSDL_PREFIX=org_libsdl_testjoystick
+
+LOCAL_SHARED_LIBRARIES := SDL2
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)
diff -r 5ce21e1ca0c3 android/testjoystick/lint.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/lint.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+</lint>
\ No newline at end of file
diff -r 5ce21e1ca0c3 android/testjoystick/proguard-project.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/proguard-project.txt	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -r 5ce21e1ca0c3 android/testjoystick/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/project.properties	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
diff -r 5ce21e1ca0c3 android/testjoystick/res/drawable-hdpi/ic_launcher.png
Binary file android/testjoystick/res/drawable-hdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testjoystick/res/drawable-mdpi/ic_launcher.png
Binary file android/testjoystick/res/drawable-mdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testjoystick/res/drawable-xhdpi/ic_launcher.png
Binary file android/testjoystick/res/drawable-xhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testjoystick/res/drawable-xxhdpi/ic_launcher.png
Binary file android/testjoystick/res/drawable-xxhdpi/ic_launcher.png has changed
diff -r 5ce21e1ca0c3 android/testjoystick/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/res/layout/main.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+
diff -r 5ce21e1ca0c3 android/testjoystick/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/res/values/strings.xml	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Test Joystick</string>
+</resources>
diff -r 5ce21e1ca0c3 android/testjoystick/src/org/libsdl/testjoystick/SDLActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/testjoystick/src/org/libsdl/testjoystick/SDLActivity.java	Sat Nov 16 12:08:10 2013 -0800
@@ -0,0 +1,856 @@
+package org.libsdl.testjoystick;
+
+import java.util.Arrays;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+import java.lang.*;
+import java.util.List;
+import java.util.ArrayList;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused = false, mIsSurfaceReady = false, mHasFocus = true;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Joystick
+    private static List<Integer> mJoyIdList;
+
+    // Audio
+    protected static Thread mAudioThread;
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        //System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        //Log.v("SDL", "onCreate()");
+        super.onCreate(savedInstanceState);
+        
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (mSDLThread != null) {
+            try {
+                mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native void onNativePadDown(int padId, int keycode);
+    public static native void onNativePadUp(int padId, int keycode);
+    public static native void onNativeJoy(int joyId, int axis,
+                                          float value);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+    
+    // Create a list of valid ID's the first time this function is called
+    private static void createJoystickList() {
+        if(mJoyIdList != null) {
+            return;
+        }
+        
+        mJoyIdList = new ArrayList<Integer>();
+        // InputDevice.getDeviceIds requires SDK >= 16
+        if(Build.VERSION.SDK_INT >= 16) {
+            int[] deviceIds = InputDevice.getDeviceIds();
+            for(int i=0; i<deviceIds.length; i++) {
+                if( (InputDevice.getDevice(deviceIds[i]).getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    mJoyIdList.add(deviceIds[i]);
+                }
+            }
+        }
+    }
+    
+    public static int getNumJoysticks() {
+        createJoystickList();
+        
+        return mJoyIdList.size();
+    }
+    
+    public static String getJoystickName(int joy) {
+        createJoystickList();
+        
+        return InputDevice.getDevice(mJoyIdList.get(joy)).getName();
+    }
+    
+    public static int getJoystickAxes(int joy) {
+        createJoystickList();
+        
+        // In newer Android versions we can get a real value
+        // In older versions, we can assume a sane X-Y default configuration
+        if(Build.VERSION.SDK_INT >= 12) {
+            return InputDevice.getDevice(mJoyIdList.get(joy)).getMotionRanges().size();
+        } else {
+            return 2;
+        }
+    }
+    
+    public static int getJoyId(int devId) {
+        int i=0;
+        
+        createJoystickList();
+        
+        for(i=0; i<mJoyIdList.size(); i++) {
+            if(mJoyIdList.get(i) == devId) {
+                return i;
+            }
+        }
+        
+        return -1;
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new genericMotionHandler());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        if(event.getSource() == InputDevice.SOURCE_KEYBOARD) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+        } else if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            int id = SDLActivity.getJoyId( event.getDeviceId() );
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                SDLActivity.onNativePadDown(id, keyCode);
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                SDLActivity.onNativePadUp(id, keyCode);
+            }
+        }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+             final int touchDevId = event.getDeviceId();
+             final int pointerCount = event.getPointerCount();
+             // touchId, pointerId, action, x, y, pressure
+             int actionPointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT; /* API 8: event.getActionIndex(); */
+             int pointerFingerId = event.getPointerId(actionPointerIndex);
+             int action = (event.getAction() & MotionEvent.ACTION_MASK); /* API 8: event.getActionMasked(); */
+
+             float x = event.getX(actionPointerIndex) / mWidth;
+             float y = event.getY(actionPointerIndex) / mHeight;
+             float p = event.getPressure(actionPointerIndex);
+
+             if (action == MotionEvent.ACTION_MOVE && pointerCount > 1) {
+                // TODO send motion to every pointer if its position has
+                // changed since prev event.
+                for (int i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+             } else {
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+             }
+      return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            SDLActivity.onNativeAccel(event.values[0] / SensorManager.GRAVITY_EARTH,
+                                      event.values[1] / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH);
+        }
+    }
+    
+    class genericMotionHandler extends Activity implements View.OnGenericMotionListener {
+        // Generic Motion (mouse hover, joystick...) events go here
+        // We only have joysticks yet
+        @Override
+        public boolean onGenericMotion(View v, MotionEvent event) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            
+            if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+                switch(action) {
+                    case MotionEvent.ACTION_MOVE:
+                        int id = SDLActivity.getJoyId( event.getDeviceId() );
+                        float x = event.getAxisValue(MotionEvent.AXIS_X, actionPointerIndex);
+                        float y = event.getAxisValue(MotionEvent.AXIS_Y, actionPointerIndex);
+                        SDLActivity.onNativeJoy(id, 0, x);
+                        SDLActivity.onNativeJoy(id, 1, y);
+                        
+                        break;
+                }
+            }
+            return true;
+        }
+        
+    }
+    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+}
+
diff -r 5ce21e1ca0c3 include/SDL_hints.h
--- a/include/SDL_hints.h	Mon Oct 14 09:15:41 2013 -0700
+++ b/include/SDL_hints.h	Sat Nov 16 12:08:10 2013 -0800
@@ -203,6 +203,17 @@
  *    "LandscapeLeft", "LandscapeRight", "Portrait" "PortraitUpsideDown"
  */
 #define SDL_HINT_ORIENTATIONS "SDL_IOS_ORIENTATIONS"
+    
+/**
+ *  \brief  A variable controlling whether a built-in accelerometer should be
+ *  listed as a joystick device (and the only one), rather than listing actual
+ *  joysticks only. Currently has an effect on Android.
+ *
+ *  This variable can be set to the following values:
+ *    "0"       - List actual joysticks and accept input from them
+ *    "1"       - Emulate a built-in accelerometer as a 3-axis joystick and disable actual joystick support (the default)
+ */
+#define SDL_HINT_ACCEL_AS_JOY "SDL_ACCEL_AS_JOY"
 
 
 /**
diff -r 5ce21e1ca0c3 src/core/android/SDL_android.c
--- a/src/core/android/SDL_android.c	Mon Oct 14 09:15:41 2013 -0700
+++ b/src/core/android/SDL_android.c	Sat Nov 16 12:08:10 2013 -0800
@@ -48,6 +48,16 @@
 /* Uncomment this to log messages entering and exiting methods in this file */
 /* #define DEBUG_JNI */
 
+#ifndef SDL_PREFIX
+    #pragma warning Defaulting to org.libsdl.app
+	#define SDL_PREFIX		org_libdl_app
+#endif
+
+#define CONCAT1(p,f)	CONCAT2(p,f)
+#define CONCAT2(p,f)	Java_ ## p ## _ ## f
+
+#define JNI(f)			CONCAT1(SDL_PREFIX,f)
+
 static void Android_JNI_ThreadDestroyed(void*);
 
 /*******************************************************************************
@@ -139,7 +149,7 @@
 }
 
 /* Resize */
-void Java_org_libsdl_app_SDLActivity_onNativeResize(
+void JNI(SDLActivity_onNativeResize)(
                                     JNIEnv* env, jclass jcls,
                                     jint width, jint height, jint format)
 {
@@ -148,7 +158,7 @@
 
 
 /* Surface Created */
-void Java_org_libsdl_app_SDLActivity_onNativeSurfaceChanged(JNIEnv* env, jclass jcls)
+void JNI(SDLActivity_onNativeSurfaceChanged)(JNIEnv* env, jclass jcls)
 {
     SDL_WindowData *data;
     SDL_VideoDevice *_this;
@@ -174,7 +184,7 @@
 }
 
 /* Surface Destroyed */
-void Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(JNIEnv* env, jclass jcls)
+void JNI(SDLActivity_onNativeSurfaceDestroyed)(JNIEnv* env, jclass jcls)
 {
     /* We have to clear the current context and destroy the egl surface here
      * Otherwise there's BAD_NATIVE_WINDOW errors coming from eglCreateWindowSurface on resume
@@ -200,27 +210,51 @@
 
 }
 
-void Java_org_libsdl_app_SDLActivity_nativeFlipBuffers(JNIEnv* env, jclass jcls)
+void JNI(SDLActivity_nativeFlipBuffers)(JNIEnv* env, jclass jcls)
 {
     SDL_GL_SwapWindow(Android_Window);
 }
 
+/* Paddown */
+void JNI(SDLActivity_onNativePadDown)(
+                                                     JNIEnv* env, jclass jcls,
+                                                     jint padId, jint keycode)
+{
+    Android_OnPadDown(padId, keycode);
+}
+
+/* Padup */
+void JNI(SDLActivity_onNativePadUp)(
+                                                   JNIEnv* env, jclass jcls,
+                                                   jint padId, jint keycode)
+{
+    Android_OnPadUp(padId, keycode);
+}
+
+/* OnJoy */
+void JNI(SDLActivity_onNativeJoy)(
+                                                 JNIEnv* env, jclass jcls,
+                                                 jint joyId, jint axis, jfloat value)
+{
+    Android_OnJoy(joyId, axis, value);
+}
+
 /* Keydown */
-void Java_org_libsdl_app_SDLActivity_onNativeKeyDown(
+void JNI(SDLActivity_onNativeKeyDown)(
                                     JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyDown(keycode);
 }
 
 /* Keyup */
-void Java_org_libsdl_app_SDLActivity_onNativeKeyUp(
+void JNI(SDLActivity_onNativeKeyUp)(
                                     JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyUp(keycode);
 }
 
 /* Keyboard Focus Lost */
-void Java_org_libsdl_app_SDLActivity_onNativeKeyboardFocusLost(
+void JNI(SDLActivity_onNativeKeyboardFocusLost)(
                                     JNIEnv* env, jclass jcls)
 {
     /* Calling SDL_StopTextInput will take care of hiding the keyboard and cleaning up the DummyText widget */
@@ -229,7 +263,7 @@
 
 
 /* Touch */
-void Java_org_libsdl_app_SDLActivity_onNativeTouch(
+void JNI(SDLActivity_onNativeTouch)(
                                     JNIEnv* env, jclass jcls,
                                     jint touch_device_id_in, jint pointer_finger_id_in,
                                     jint action, jfloat x, jfloat y, jfloat p)
@@ -238,7 +272,7 @@
 }
 
 /* Accelerometer */
-void Java_org_libsdl_app_SDLActivity_onNativeAccel(
+void JNI(SDLActivity_onNativeAccel)(
                                     JNIEnv* env, jclass jcls,
                                     jfloat x, jfloat y, jfloat z)
 {
@@ -249,14 +283,14 @@
 }
 
 /* Low memory */
-void Java_org_libsdl_app_SDLActivity_nativeLowMemory(
+void JNI(SDLActivity_nativeLowMemory)(
                                     JNIEnv* env, jclass cls)
 {
     SDL_SendAppEvent(SDL_APP_LOWMEMORY);
 }
 
 /* Quit */
-void Java_org_libsdl_app_SDLActivity_nativeQuit(
+void JNI(SDLActivity_nativeQuit)(
                                     JNIEnv* env, jclass cls)
 {
     /* Inject a SDL_QUIT event */
@@ -265,7 +299,7 @@
 }
 
 /* Pause */
-void Java_org_libsdl_app_SDLActivity_nativePause(
+void JNI(SDLActivity_nativePause)(
                                     JNIEnv* env, jclass cls)
 {
     if (Android_Window) {
@@ -281,7 +315,7 @@
 }
 
 /* Resume */
-void Java_org_libsdl_app_SDLActivity_nativeResume(
+void JNI(SDLActivity_nativeResume)(
                                     JNIEnv* env, jclass cls)
 {
     __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "nativeResume()");
@@ -299,7 +333,7 @@
     }
 }
 
-void Java_org_libsdl_app_SDLInputConnection_nativeCommitText(
+void JNI(SDLInputConnection_nativeCommitText)(
                                     JNIEnv* env, jclass cls,
                                     jstring text, jint newCursorPosition)
 {
@@ -310,7 +344,7 @@
     (*env)->ReleaseStringUTFChars(env, text, utftext);
 }
 
-void Java_org_libsdl_app_SDLInputConnection_nativeSetComposingText(
+void JNI(SDLInputConnection_nativeSetComposingText)(
                                     JNIEnv* env, jclass cls,
                                     jstring text, jint newCursorPosition)
 {
@@ -1212,6 +1246,61 @@
     return number;
 }
 
+/* return the total number of plugged in joysticks */
+int Android_JNI_GetNumJoysticks()
+{
+    JNIEnv* env = Android_JNI_GetEnv();
+    if (!env) {
+        return -1;
+    }
+    
+    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "getNumJoysticks", "()I");
+    if (!mid) {
+        return -1;
+    }
+    
+    return (int)(*env)->CallStaticIntMethod(env, mActivityClass, mid);
+}
+
+/* Return the name of joystick number "i" */
+char* Android_JNI_GetJoystickName(int i)
+{
+    JNIEnv* env = Android_JNI_GetEnv();
+    if (!env) {
+        return SDL_strdup("");
+    }
+    
+    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "getJoystickName", "(I)Ljava/lang/String;");
+    if (!mid) {
+        return SDL_strdup("");
+    }
+    jstring string = (jstring)((*env)->CallStaticObjectMethod(env, mActivityClass, mid, i));
+    const char* utf = (*env)->GetStringUTFChars(env, string, 0);
+    if (!utf) {
+        return SDL_strdup("");
+    }
+    
+    char* text = SDL_strdup(utf);
+    (*env)->ReleaseStringUTFChars(env, string, utf);
+    return text;
+}
+
+/* return the number of axes in the given joystick */
+int Android_JNI_GetJoystickAxes(int joy)
+{
+    JNIEnv* env = Android_JNI_GetEnv();
+    if (!env) {
+        return -1;
+    }
+    
+    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "getJoystickAxes", "(I)I");
+    if (!mid) {
+        return -1;
+    }
+    
+    return (int)(*env)->CallIntMethod(env, mActivityClass, mid, joy);
+}
+
 /* sends message to be handled on the UI event dispatch thread */
 int Android_JNI_SendMessage(int command, int param)
 {
diff -r 5ce21e1ca0c3 src/core/android/SDL_android.h
--- a/src/core/android/SDL_android.h	Mon Oct 14 09:15:41 2013 -0700
+++ b/src/core/android/SDL_android.h	Sat Nov 16 12:08:10 2013 -0800
@@ -64,6 +64,11 @@
 
 /* Power support */
 int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seconds, int* percent);
+    
+/* Joystick support */
+int Android_JNI_GetNumJoysticks();
+char* Android_JNI_GetJoystickName(int i);
+int Android_JNI_GetJoystickAxes(int joy);
 
 /* Touch support */
 int Android_JNI_GetTouchDeviceIds(int **ids);
diff -r 5ce21e1ca0c3 src/joystick/android/SDL_sysjoystick.c
--- a/src/joystick/android/SDL_sysjoystick.c	Mon Oct 14 09:15:41 2013 -0700
+++ b/src/joystick/android/SDL_sysjoystick.c	Sat Nov 16 12:08:10 2013 -0800
@@ -29,12 +29,48 @@
 #include "SDL_error.h"
 #include "SDL_events.h"
 #include "SDL_joystick.h"
+#include "SDL_hints.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
 #include "../../core/android/SDL_android.h"
 
 static const char *accelerometerName = "Android accelerometer";
 
+static SDL_Joystick **SYS_Joysticks;
+static char **SYS_JoystickNames;
+static int SYS_numjoysticks;
+static SDL_bool SYS_accelAsJoy;
+
+/* Function to convert Android keyCodes into SDL ones.
+ * This code manipulation is done to get a sequential list of codes.
+ */
+int
+keycode_to_SDL(int keycode)
+{
+    int final = 0;
+    /* D-Pad key codes (API 1):
+     * KEYCODE_DPAD_UP=19, KEYCODE_DPAD_DOWN
+     * KEYCODE_DPAD_LEFT, KEYCODE_DPAD_RIGHT, KEYCODE_DPAD_CENTER
+     */
+    if(keycode < 96)
+        return keycode-19;
+    /* Some gamepad buttons (API 9):
+     * KEYCODE_BUTTON_A=96, KEYCODE_BUTTON_B, KEYCODE_BUTTON_C,
+     * KEYCODE_BUTTON_X, KEYCODE_BUTTON_Y, KEYCODE_BUTTON_Z,
+     * KEYCODE_BUTTON_L1, KEYCODE_BUTTON_L2,
+     * KEYCODE_BUTTON_R1, KEYCODE_BUTTON_R2,
+     * KEYCODE_BUTTON_THUMBL, KEYCODE_BUTTON_THUMBR,
+     * KEYCODE_BUTTON_START, KEYCODE_BUTTON_SELECT, KEYCODE_BUTTON_MODE
+     */
+    else if(keycode < 188)
+        return keycode-91;
+    /* More gamepad buttons (API 12):
+     * KEYCODE_BUTTON_1=188 to KEYCODE_BUTTON_16
+     */
+    else
+        return keycode-168;
+}
+
 /* Function to scan the system for joysticks.
  * This function should set SDL_numjoysticks to the number of available
  * joysticks.  Joystick 0 should be the system default joystick.
@@ -43,12 +79,58 @@
 int
 SDL_SYS_JoystickInit(void)
 {
+    int i = 0;
+    const char *env;
+    
+    // Should we emulate the accelerometer as a joystick?
+    env = SDL_GetHint(SDL_HINT_ACCEL_AS_JOY);
+    if (env && !SDL_atoi(env))
+        SYS_accelAsJoy = SDL_FALSE;
+    else
+        SYS_accelAsJoy = SDL_TRUE; /* Default behavior */
+    
+    SYS_numjoysticks = Android_JNI_GetNumJoysticks();
+    if (SYS_accelAsJoy) {
+        SYS_numjoysticks++;
+    }
+    SYS_Joysticks = (SDL_Joystick **)SDL_malloc(SYS_numjoysticks*sizeof(SDL_Joystick *));
+    if (SYS_Joysticks == NULL)
+    {
+        SDL_OutOfMemory();
+        return (-1);
+    }
+    SYS_JoystickNames = (char **)SDL_malloc(SYS_numjoysticks*sizeof(char *));
+    if (SYS_JoystickNames == NULL)
+    {
+        SDL_free(SYS_Joysticks);
+        SYS_Joysticks = NULL;
+        SDL_OutOfMemory();
+        return (-1);
+    }
+    SDL_memset(SYS_JoystickNames, 0, (SYS_numjoysticks*sizeof(char *)));
+    SDL_memset(SYS_Joysticks, 0, (SYS_numjoysticks*sizeof(SDL_Joystick *)));
+    
+    for (i = 0; i < SYS_numjoysticks; i++)
+    {
+        if (SYS_accelAsJoy && i == (SYS_numjoysticks-1)) {
+            SYS_JoystickNames[i] = accelerometerName;
+        } else {
+            SYS_JoystickNames[i] = Android_JNI_GetJoystickName(i);
+        }
+    }
+    
+    if (SYS_accelAsJoy) {
+        SYS_JoystickNames[SYS_numjoysticks-1] = accelerometerName;
+    }
+    
+    return (SYS_numjoysticks);
+    
     return (1);
 }
 
 int SDL_SYS_NumJoysticks()
 {
-    return 1;
+    return SYS_numjoysticks;
 }
 
 void SDL_SYS_JoystickDetect()
@@ -64,7 +146,7 @@
 const char *
 SDL_SYS_JoystickNameForDeviceIndex(int device_index)
 {
-    return accelerometerName;
+    return SYS_JoystickNames[device_index];
 }
 
 /* Function to perform the mapping from device index to the instance id for this index */
@@ -81,11 +163,19 @@
 int
 SDL_SYS_JoystickOpen(SDL_Joystick * joystick, int device_index)
 {
-    if (device_index == 0) {
-        joystick->nbuttons = 0;
+    if (device_index < SYS_numjoysticks) {
         joystick->nhats = 0;
         joystick->nballs = 0;
-        joystick->naxes = 3;
+        if (SYS_accelAsJoy && device_index == (SYS_numjoysticks-1)) {
+            joystick->nbuttons = 0;
+            joystick->naxes = 3;
+        } else {
+            // TODO: Get the real number of buttons in the device
+            joystick->nbuttons = 36;
+            joystick->naxes = Android_JNI_GetJoystickAxes(device_index);
+        }
+        
+        SYS_Joysticks[device_index] = joystick;
         return 0;
     } else {
         SDL_SetError("No joystick available with that index");
@@ -111,7 +201,8 @@
     Sint16 value;
     float values[3];
 
-    if (Android_JNI_GetAccelerometerValues(values)) {
+    if (SYS_accelAsJoy && Android_JNI_GetAccelerometerValues(values) &&
+        joystick->instance_id == (SYS_numjoysticks-1)) {
         for ( i = 0; i < 3; i++ ) {
             value = (Sint16)(values[i] * 32767.0f);
             SDL_PrivateJoystickAxis(joystick, i, value);
@@ -129,6 +220,10 @@
 void
 SDL_SYS_JoystickQuit(void)
 {
+    SDL_free(SYS_JoystickNames);
+    SDL_free(SYS_Joysticks);
+    SYS_JoystickNames = NULL;
+    SYS_Joysticks = NULL;
 }
 
 SDL_JoystickGUID SDL_SYS_JoystickGetDeviceGUID( int device_index )
@@ -151,6 +246,32 @@
     return guid;
 }
 
+int
+Android_OnPadDown(int padId, int keycode)
+{
+    SDL_PrivateJoystickButton(SYS_Joysticks[padId], keycode_to_SDL(keycode), SDL_PRESSED);
+    
+    return 0;
+}
+
+int
+Android_OnPadUp(int padId, int keycode)
+{
+    SDL_PrivateJoystickButton(SYS_Joysticks[padId], keycode_to_SDL(keycode), SDL_RELEASED);
+    
+    return 0;
+}
+
+int
+Android_OnJoy(int joyId, int axis, double value)
+{
+    // Android gives joy info normalized as [-1.0, 1.0] or [0.0, 1.0]
+    // TODO: Are the reported values right?
+    SDL_PrivateJoystickAxis(SYS_Joysticks[joyId], axis, (Sint16) (32767.*value) );
+    
+    return 0;
+}
+
 #endif /* SDL_JOYSTICK_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff -r 5ce21e1ca0c3 src/main/android/SDL_android_main.c
--- a/src/main/android/SDL_android_main.c	Mon Oct 14 09:15:41 2013 -0700
+++ b/src/main/android/SDL_android_main.c	Sat Nov 16 12:08:10 2013 -0800
@@ -6,6 +6,16 @@
 /* Include the SDL main definition header */
 #include "SDL_main.h"
 
+#ifndef SDL_PREFIX
+    #pragma warning Defaulting to org.libsdl.app
+	#define SDL_PREFIX		org_libdl_app
+#endif
+
+#define CONCAT1(p,f)	CONCAT2(p,f)
+#define CONCAT2(p,f)	Java_ ## p ## _ ## f
+
+#define JNI(f)			CONCAT1(SDL_PREFIX,f)
+
 /*******************************************************************************
                  Functions called by JNI
 *******************************************************************************/
@@ -15,7 +25,7 @@
 extern void SDL_Android_Init(JNIEnv* env, jclass cls);
 
 /* Start up the SDL app */
-void Java_org_libsdl_app_SDLActivity_nativeInit(JNIEnv* env, jclass cls, jobject obj)
+void JNI(SDLActivity_nativeInit)(JNIEnv* env, jclass cls, jobject obj)
 {
     /* This interface could expand with ABI negotiation, calbacks, etc. */
     SDL_Android_Init(env, cls);
diff -r 5ce21e1ca0c3 test/testjoystick.c
--- a/test/testjoystick.c	Mon Oct 14 09:15:41 2013 -0700
+++ b/test/testjoystick.c	Sat Nov 16 12:08:10 2013 -0800
@@ -20,20 +20,32 @@
 
 #ifndef SDL_JOYSTICK_DISABLED
 
-#ifdef __IPHONEOS__
-#define SCREEN_WIDTH    320
-#define SCREEN_HEIGHT   480
-#else
-#define SCREEN_WIDTH    640
-#define SCREEN_HEIGHT   480
-#endif
+int SCREEN_WIDTH = 640;
+int SCREEN_HEIGHT = 480;
 
+static void 
+SDL_RenderDrawBox(SDL_Renderer* r, const SDL_Rect* rect)
+{
+	const int left = rect->x;
+	const int top = rect->y;
+	const int right = rect->x + rect->w;
+	const int bottom = rect->y + rect->h;
+    SDL_RenderDrawLine(r, left,  top,    right, top);		// top edge
+    SDL_RenderDrawLine(r, left,  top,    left,  bottom);		// right edge
+    SDL_RenderDrawLine(r, right, top,    right, bottom);		// right edge
+    SDL_RenderDrawLine(r, left,  bottom, right, bottom);		// bottom edge
+}
 
-static void
-DrawRect(SDL_Renderer *r, const int x, const int y, const int w, const int h)
+static int 
+ScaleCoord(short int x, int max)
 {
-    const SDL_Rect area = { x, y, w, h };
-    SDL_RenderFillRect(r, &area);
+    x = ((int) x * max) / 65536 + max / 2;
+    if (x < 0) {
+        x = 0;
+    } else if (x > max) {
+        x = max;
+    }
+	return x;
 }
 
 static SDL_bool
@@ -45,16 +57,18 @@
     SDL_bool retval = SDL_FALSE;
     SDL_bool done = SDL_FALSE;
     SDL_Event event;
-    int i;
+    int i, nAxes, nButtons;
 
     /* Create a window to display joystick axis position */
     window = SDL_CreateWindow("Joystick Test", SDL_WINDOWPOS_CENTERED,
-                              SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH,
-                              SCREEN_HEIGHT, 0);
+                              SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH,SCREEN_HEIGHT,
+                              SDL_WINDOW_FULLSCREEN_DESKTOP);
     if (window == NULL) {
         SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create window: %s\n", SDL_GetError());
         return SDL_FALSE;
     }
+	
+	SDL_GetWindowSize(window, &SCREEN_WIDTH, &SCREEN_HEIGHT);
 
     screen = SDL_CreateRenderer(window, -1, 0);
     if (screen == NULL) {
@@ -70,11 +84,14 @@
 
     /* Print info about the joystick we are watching */
     name = SDL_JoystickName(joystick);
+	nAxes = SDL_JoystickNumAxes(joystick);
+	nButtons = SDL_JoystickNumButtons(joystick);
+
     SDL_Log("Watching joystick %d: (%s)\n", SDL_JoystickInstanceID(joystick),
            name ? name : "Unknown Joystick");
     SDL_Log("Joystick has %d axes, %d hats, %d balls, and %d buttons\n",
-           SDL_JoystickNumAxes(joystick), SDL_JoystickNumHats(joystick),
-           SDL_JoystickNumBalls(joystick), SDL_JoystickNumButtons(joystick));
+           nAxes, SDL_JoystickNumHats(joystick),
+           SDL_JoystickNumBalls(joystick), nButtons);
 
     /* Loop, getting joystick events! */
     while (!done) {
@@ -135,45 +152,39 @@
         /* Update visual joystick state */
         SDL_SetRenderDrawColor(screen, 0x00, 0xFF, 0x00, SDL_ALPHA_OPAQUE);
         for (i = 0; i < SDL_JoystickNumButtons(joystick); ++i) {
+			const SDL_Rect rect = { (i%20) * 34, SCREEN_HEIGHT - 68 + (i/20) * 34, 32, 32 };
             if (SDL_JoystickGetButton(joystick, i) == SDL_PRESSED) {
-                DrawRect(screen, (i%20) * 34, SCREEN_HEIGHT - 68 + (i/20) * 34, 32, 32);
-            }
+                SDL_RenderFillRect(screen, &rect);
+			} else {
+				SDL_RenderDrawBox(screen, &rect);
+			}
         }
 
         SDL_SetRenderDrawColor(screen, 0xFF, 0x00, 0x00, SDL_ALPHA_OPAQUE);
-        for (i = 0; i < SDL_JoystickNumAxes(joystick); ++i) {
+        for (i = 0; i < nAxes; ++i) {
             /* Draw the X/Y axis */
             int x, y;
-            x = (((int) SDL_JoystickGetAxis(joystick, i)) + 32768);
-            x *= SCREEN_WIDTH;
-            x /= 65535;
-            if (x < 0) {
-                x = 0;
-            } else if (x > (SCREEN_WIDTH - 16)) {
-                x = SCREEN_WIDTH - 16;
+            x = (short int) SDL_JoystickGetAxis(joystick, i);
+			x = ScaleCoord(x, SCREEN_WIDTH - 16);
+            ++i;
+            if (i < nAxes) {
+                y = (short int) SDL_JoystickGetAxis(joystick, i);
+            } else {
+                y = 0;
             }
-            ++i;
-            if (i < SDL_JoystickNumAxes(joystick)) {
-                y = (((int) SDL_JoystickGetAxis(joystick, i)) + 32768);
-            } else {
-                y = 32768;
-            }
-            y *= SCREEN_HEIGHT;
-            y /= 65535;
-            if (y < 0) {
-                y = 0;
-            } else if (y > (SCREEN_HEIGHT - 16)) {
-                y = SCREEN_HEIGHT - 16;
-            }
-
-            DrawRect(screen, x, y, 16, 16);
+			y = ScaleCoord(y, SCREEN_HEIGHT - 16);
+			{
+//				SDL_Log("x=%d y=%d xmin=%d xmax=%d ymin=%d ymax=%d\n", x, y, xmin, xmax, ymin, ymax);
+				const SDL_Rect rect = { x, y, 16, 16 };
+				SDL_RenderFillRect(screen, &rect);
+			}
         }
 
         SDL_SetRenderDrawColor(screen, 0x00, 0x00, 0xFF, SDL_ALPHA_OPAQUE);
         for (i = 0; i < SDL_JoystickNumHats(joystick); ++i) {
             /* Derive the new position */
-            int x = SCREEN_WIDTH/2;
-            int y = SCREEN_HEIGHT/2;
+            int x = SCREEN_WIDTH/2 + 4;
+            int y = SCREEN_HEIGHT/2 + 4;
             const Uint8 hat_pos = SDL_JoystickGetHat(joystick, i);
 
             if (hat_pos & SDL_HAT_UP) {
@@ -188,7 +199,10 @@
                 x = SCREEN_WIDTH-8;
             }
 
-            DrawRect(screen, x, y, 8, 8);
+			{
+				const SDL_Rect rect = { x, y, 8, 8 };
+				SDL_RenderFillRect(screen, &rect);
+			}
         }
 
         SDL_RenderPresent(screen);
@@ -197,6 +211,7 @@
             done = SDL_TRUE;
             retval = SDL_TRUE;  /* keep going, wait for reattach. */
         }
+		SDL_Delay(1);
     }
 
     SDL_DestroyRenderer(screen);
@@ -208,7 +223,7 @@
 main(int argc, char *argv[])
 {
     const char *name;
-    int i;
+    int i, joyid;
     SDL_Joystick *joystick;
 
     /* Enable standard application logging */
@@ -243,20 +258,15 @@
         }
     }
 
-#ifdef ANDROID
     if (SDL_NumJoysticks() > 0) {
-#else
-    if (argv[1]) {
-#endif
+		/* Get joystick id from command line (default to joyid 0) */
+		int joyid = argv[1] ? atoi(argv[1]) : 0;
         SDL_bool reportederror = SDL_FALSE;
         SDL_bool keepGoing = SDL_TRUE;
         SDL_Event event;
-#ifdef ANDROID
-        joystick = SDL_JoystickOpen(0);
-#else
-        joystick = SDL_JoystickOpen(atoi(argv[1]));
-#endif
-        while ( keepGoing ) {
+        joystick = SDL_JoystickOpen(joyid);
+
+		while ( keepGoing ) {
             if (joystick == NULL) {
                 if ( !reportederror ) {
                     SDL_Log("Couldn't open joystick %d: %s\n", atoi(argv[1]), SDL_GetError());
